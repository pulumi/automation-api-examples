"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const settings_1 = require("../runtime/settings");
const engproto = require("../proto/engine_pb.js");
let errcnt = 0;
let lastLog = Promise.resolve();
/**
 * hasErrors returns true if any errors have occurred in the program.
 */
function hasErrors() {
    return errcnt > 0;
}
exports.hasErrors = hasErrors;
/**
 * debug logs a debug-level message that is generally hidden from end-users.
 */
function debug(msg, resource, streamId, ephemeral) {
    const engine = settings_1.getEngine();
    if (engine) {
        return log(engine, engproto.LogSeverity.DEBUG, msg, resource, streamId, ephemeral);
    }
    else {
        return Promise.resolve();
    }
}
exports.debug = debug;
/**
 * info logs an informational message that is generally printed to stdout during resource operations.
 */
function info(msg, resource, streamId, ephemeral) {
    const engine = settings_1.getEngine();
    if (engine) {
        return log(engine, engproto.LogSeverity.INFO, msg, resource, streamId, ephemeral);
    }
    else {
        console.log(`info: [runtime] ${msg}`);
        return Promise.resolve();
    }
}
exports.info = info;
/**
 * warn logs a warning to indicate that something went wrong, but not catastrophically so.
 */
function warn(msg, resource, streamId, ephemeral) {
    const engine = settings_1.getEngine();
    if (engine) {
        return log(engine, engproto.LogSeverity.WARNING, msg, resource, streamId, ephemeral);
    }
    else {
        console.warn(`warning: [runtime] ${msg}`);
        return Promise.resolve();
    }
}
exports.warn = warn;
/**
 * error logs a fatal error to indicate that the tool should stop processing resource operations immediately.
 */
function error(msg, resource, streamId, ephemeral) {
    errcnt++; // remember the error so we can suppress leaks.
    const engine = settings_1.getEngine();
    if (engine) {
        return log(engine, engproto.LogSeverity.ERROR, msg, resource, streamId, ephemeral);
    }
    else {
        console.error(`error: [runtime] ${msg}`);
        return Promise.resolve();
    }
}
exports.error = error;
function log(engine, sev, msg, resource, streamId, ephemeral) {
    // Ensure we log everything in serial order.
    const keepAlive = settings_1.rpcKeepAlive();
    const urnPromise = resource
        ? resource.urn.promise()
        : Promise.resolve("");
    lastLog = Promise.all([lastLog, urnPromise]).then(([_, urn]) => {
        return new Promise((resolve, reject) => {
            try {
                const req = new engproto.LogRequest();
                req.setSeverity(sev);
                req.setMessage(msg);
                req.setUrn(urn);
                req.setStreamid(streamId === undefined ? 0 : streamId);
                req.setEphemeral(ephemeral === true);
                engine.log(req, () => {
                    resolve(); // let the next log through
                    keepAlive(); // permit RPC channel tear-downs
                });
            }
            catch (err) {
                reject(err);
            }
        });
    });
    return lastLog.catch(() => undefined);
}
