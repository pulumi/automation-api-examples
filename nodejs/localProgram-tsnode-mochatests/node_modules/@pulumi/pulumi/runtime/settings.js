"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const grpc = require("@grpc/grpc-js");
const fs = require("fs");
const path = require("path");
const debuggable_1 = require("./debuggable");
const engrpc = require("../proto/engine_grpc_pb.js");
const engproto = require("../proto/engine_pb.js");
const provproto = require("../proto/provider_pb.js");
const resrpc = require("../proto/resource_grpc_pb.js");
const resproto = require("../proto/resource_pb.js");
const structproto = require("google-protobuf/google/protobuf/struct_pb.js");
// maxRPCMessageSize raises the gRPC Max Message size from `4194304` (4mb) to `419430400` (400mb)
exports.maxRPCMessageSize = 1024 * 1024 * 400;
const grpcChannelOptions = { "grpc.max_receive_message_length": exports.maxRPCMessageSize };
/**
 * excessiveDebugOutput enables, well, pretty excessive debug output pertaining to resources and properties.
 */
exports.excessiveDebugOutput = false;
/**
 * options are the current deployment options being used for this entire session.
 */
let options = loadOptions();
function resetOptions(project, stack, parallel, engineAddr, monitorAddr, preview) {
    monitor = undefined;
    engine = undefined;
    rootResource = undefined;
    rpcDone = Promise.resolve();
    options = {
        project,
        stack,
        parallel,
        engineAddr,
        monitorAddr,
        dryRun: preview,
    };
}
exports.resetOptions = resetOptions;
function setMockOptions(mockMonitor, project, stack, preview) {
    options = {
        project: project || options.project || "project",
        stack: stack || options.stack || "stack",
        dryRun: preview,
        queryMode: options.queryMode,
        parallel: options.parallel,
        monitorAddr: options.monitorAddr,
        engineAddr: options.engineAddr,
        testModeEnabled: true,
        legacyApply: options.legacyApply,
        syncDir: options.syncDir,
    };
    monitor = mockMonitor;
}
exports.setMockOptions = setMockOptions;
/** @internal Used only for testing purposes. */
function _setIsDryRun(val) {
    options.dryRun = val;
}
exports._setIsDryRun = _setIsDryRun;
/**
 * Returns true if we're currently performing a dry-run, or false if this is a true update. Note that we
 * always consider executions in test mode to be "dry-runs", since we will never actually carry out an update,
 * and therefore certain output properties will never be resolved.
 */
function isDryRun() {
    return options.dryRun === true;
}
exports.isDryRun = isDryRun;
/** @internal Used only for testing purposes */
function _setTestModeEnabled(val) {
    options.testModeEnabled = val;
}
exports._setTestModeEnabled = _setTestModeEnabled;
/**
 * Returns true if test mode is enabled (PULUMI_TEST_MODE).
 */
function isTestModeEnabled() {
    return options.testModeEnabled === true;
}
exports.isTestModeEnabled = isTestModeEnabled;
/**
 * Checks that test mode is enabled and, if not, throws an error.
 */
function requireTestModeEnabled() {
    if (!isTestModeEnabled()) {
        throw new Error("Program run without the Pulumi engine available; re-run using the `pulumi` CLI");
    }
}
/** @internal Used only for testing purposes. */
function _setQueryMode(val) {
    options.queryMode = val;
}
exports._setQueryMode = _setQueryMode;
/**
 * Returns true if query mode is enabled.
 */
function isQueryMode() {
    return options.queryMode === true;
}
exports.isQueryMode = isQueryMode;
/**
 * Returns true if we will resolve missing outputs to inputs during preview (PULUMI_ENABLE_LEGACY_APPLY).
 */
function isLegacyApplyEnabled() {
    return options.legacyApply === true;
}
exports.isLegacyApplyEnabled = isLegacyApplyEnabled;
/**
 * Get the project being run by the current update.
 */
function getProject() {
    if (options.project) {
        return options.project;
    }
    // If the project is missing, specialize the error. First, if test mode is disabled:
    requireTestModeEnabled();
    // And now an error if test mode is enabled, instructing how to manually configure the project:
    throw new Error("Missing project name; for test mode, please call `pulumi.runtime.setMocks`");
}
exports.getProject = getProject;
/** @internal Used only for testing purposes. */
function _setProject(val) {
    options.project = val;
}
exports._setProject = _setProject;
/**
 * Get the stack being targeted by the current update.
 */
function getStack() {
    if (options.stack) {
        return options.stack;
    }
    // If the stack is missing, specialize the error. First, if test mode is disabled:
    requireTestModeEnabled();
    // And now an error if test mode is enabled, instructing how to manually configure the stack:
    throw new Error("Missing stack name; for test mode, please set PULUMI_NODEJS_STACK");
}
exports.getStack = getStack;
/** @internal Used only for testing purposes. */
function _setStack(val) {
    options.stack = val;
}
exports._setStack = _setStack;
/**
 * monitor is a live connection to the resource monitor that tracks deployments (lazily initialized).
 */
let monitor;
const featureSupport = {};
/**
 * hasMonitor returns true if we are currently connected to a resource monitoring service.
 */
function hasMonitor() {
    return !!monitor && !!options.monitorAddr;
}
exports.hasMonitor = hasMonitor;
/**
 * getMonitor returns the current resource monitoring service client for RPC communications.
 */
function getMonitor() {
    if (monitor === undefined) {
        const addr = options.monitorAddr;
        if (addr) {
            // Lazily initialize the RPC connection to the monitor.
            monitor = new resrpc.ResourceMonitorClient(addr, grpc.credentials.createInsecure(), grpcChannelOptions);
        }
        else {
            // If test mode isn't enabled, we can't run the program without an engine.
            requireTestModeEnabled();
        }
    }
    return monitor;
}
exports.getMonitor = getMonitor;
let syncInvokes;
/** @internal */
function tryGetSyncInvokes() {
    if (syncInvokes === undefined && options.syncDir) {
        const requests = fs.openSync(path.join(options.syncDir, "invoke_req"), fs.constants.O_WRONLY | fs.constants.O_SYNC);
        const responses = fs.openSync(path.join(options.syncDir, "invoke_res"), fs.constants.O_RDONLY | fs.constants.O_SYNC);
        syncInvokes = { requests, responses };
    }
    return syncInvokes;
}
exports.tryGetSyncInvokes = tryGetSyncInvokes;
/**
 * engine is a live connection to the engine, used for logging, etc. (lazily initialized).
 */
let engine;
/**
 * hasEngine returns true if we are currently connected to an engine.
 */
function hasEngine() {
    return !!engine && !!options.engineAddr;
}
exports.hasEngine = hasEngine;
/**
 * getEngine returns the current engine, if any, for RPC communications back to the resource engine.
 */
function getEngine() {
    if (engine === undefined) {
        const addr = options.engineAddr;
        if (addr) {
            // Lazily initialize the RPC connection to the engine.
            engine = new engrpc.EngineClient(addr, grpc.credentials.createInsecure(), grpcChannelOptions);
        }
    }
    return engine;
}
exports.getEngine = getEngine;
function terminateRpcs() {
    disconnectSync();
}
exports.terminateRpcs = terminateRpcs;
/**
 * serialize returns true if resource operations should be serialized.
 */
function serialize() {
    return options.parallel === 1;
}
exports.serialize = serialize;
/**
 * loadOptions recovers the options from the environment, which is set before we begin executing. This ensures
 * that even when multiple copies of this module are loaded, they all get the same values.
 */
function loadOptions() {
    // The only option that needs parsing is the parallelism flag.  Ignore any failures.
    let parallel;
    const parallelOpt = process.env["PULUMI_NODEJS_PARALLEL"];
    if (parallelOpt) {
        try {
            parallel = parseInt(parallelOpt, 10);
        }
        catch (err) {
            // ignore.
        }
    }
    // Now just hydrate the rest from environment variables.  These might be missing, in which case
    // we will fail later on when we actually need to create an RPC connection back to the engine.
    return {
        project: process.env["PULUMI_NODEJS_PROJECT"],
        stack: process.env["PULUMI_NODEJS_STACK"],
        dryRun: (process.env["PULUMI_NODEJS_DRY_RUN"] === "true"),
        queryMode: (process.env["PULUMI_NODEJS_QUERY_MODE"] === "true"),
        parallel: parallel,
        monitorAddr: process.env["PULUMI_NODEJS_MONITOR"],
        engineAddr: process.env["PULUMI_NODEJS_ENGINE"],
        testModeEnabled: (process.env["PULUMI_TEST_MODE"] === "true"),
        legacyApply: (process.env["PULUMI_ENABLE_LEGACY_APPLY"] === "true"),
        syncDir: process.env["PULUMI_NODEJS_SYNC"],
    };
}
/**
 * disconnect permanently disconnects from the server, closing the connections.  It waits for the existing RPC
 * queue to drain.  If any RPCs come in afterwards, however, they will crash the process.
 */
function disconnect() {
    let done;
    const closeCallback = () => {
        if (done !== rpcDone) {
            // If the done promise has changed, some activity occurred in between callbacks.  Wait again.
            done = rpcDone;
            return debuggable_1.debuggablePromise(done.then(closeCallback), "disconnect");
        }
        disconnectSync();
        return Promise.resolve();
    };
    return closeCallback();
}
exports.disconnect = disconnect;
/**
 * disconnectSync permanently disconnects from the server, closing the connections. Unlike `disconnect`. it does not
 * wait for the existing RPC queue to drain. Any RPCs that come in after this call will crash the process.
 */
function disconnectSync() {
    // Otherwise, actually perform the close activities (ignoring errors and crashes).
    if (monitor) {
        try {
            monitor.close();
        }
        catch (err) {
            // ignore.
        }
        monitor = null;
    }
    if (engine) {
        try {
            engine.close();
        }
        catch (err) {
            // ignore.
        }
        engine = null;
    }
}
exports.disconnectSync = disconnectSync;
/**
 * rpcDone resolves when the last known client-side RPC call finishes.
 */
let rpcDone = Promise.resolve();
/**
 * rpcKeepAlive registers a pending call to ensure that we don't prematurely disconnect from the server.  It returns
 * a function that, when invoked, signals that the RPC has completed.
 */
function rpcKeepAlive() {
    let done = undefined;
    const donePromise = debuggable_1.debuggablePromise(new Promise(resolve => done = resolve), "rpcKeepAlive");
    rpcDone = rpcDone.then(() => donePromise);
    return done;
}
exports.rpcKeepAlive = rpcKeepAlive;
let rootResource;
/**
 * getRootResource returns a root resource URN that will automatically become the default parent of all resources.  This
 * can be used to ensure that all resources without explicit parents are parented to a common parent resource.
 */
function getRootResource() {
    const engineRef = getEngine();
    if (!engineRef) {
        return Promise.resolve(undefined);
    }
    const req = new engproto.GetRootResourceRequest();
    return new Promise((resolve, reject) => {
        engineRef.getRootResource(req, (err, resp) => {
            // Back-compat case - if the engine we're speaking to isn't aware that it can save and load root resources,
            // fall back to the old behavior.
            if (err && err.code === grpc.status.UNIMPLEMENTED) {
                if (rootResource) {
                    rootResource.then(resolve);
                    return;
                }
                resolve(undefined);
            }
            if (err) {
                return reject(err);
            }
            const urn = resp.getUrn();
            if (urn) {
                return resolve(urn);
            }
            return resolve(undefined);
        });
    });
}
exports.getRootResource = getRootResource;
/**
 * setRootResource registers a resource that will become the default parent for all resources without explicit parents.
 */
function setRootResource(res) {
    return __awaiter(this, void 0, void 0, function* () {
        const engineRef = getEngine();
        if (!engineRef) {
            return Promise.resolve();
        }
        const req = new engproto.SetRootResourceRequest();
        const urn = yield res.urn.promise();
        req.setUrn(urn);
        return new Promise((resolve, reject) => {
            engineRef.setRootResource(req, (err, resp) => {
                // Back-compat case - if the engine we're speaking to isn't aware that it can save and load root resources,
                // fall back to the old behavior.
                if (err && err.code === grpc.status.UNIMPLEMENTED) {
                    rootResource = res.urn.promise();
                    return resolve();
                }
                if (err) {
                    return reject(err);
                }
                return resolve();
            });
        });
    });
}
exports.setRootResource = setRootResource;
/**
 * monitorSupportsFeature returns a promise that when resolved tells you if the resource monitor we are connected
 * to is able to support a particular feature.
 */
function monitorSupportsFeature(feature) {
    return __awaiter(this, void 0, void 0, function* () {
        const monitorRef = getMonitor();
        if (!monitorRef) {
            return false;
        }
        if (featureSupport[feature] === undefined) {
            const req = new resproto.SupportsFeatureRequest();
            req.setId(feature);
            const result = yield new Promise((resolve, reject) => {
                monitorRef.supportsFeature(req, (err, resp) => {
                    // Back-compat case - if the monitor doesn't let us ask if it supports a feature, it doesn't support
                    // secrets.
                    if (err && err.code === grpc.status.UNIMPLEMENTED) {
                        return resolve(false);
                    }
                    if (err) {
                        return reject(err);
                    }
                    return resolve(resp.getHassupport());
                });
            });
            featureSupport[feature] = result;
        }
        return featureSupport[feature];
    });
}
exports.monitorSupportsFeature = monitorSupportsFeature;
/**
 * monitorSupportsSecrets returns a promise that when resolved tells you if the resource monitor we are connected
 * to is able to support secrets across its RPC interface. When it does, we marshal outputs marked with the secret
 * bit in a special way.
 */
function monitorSupportsSecrets() {
    return monitorSupportsFeature("secrets");
}
exports.monitorSupportsSecrets = monitorSupportsSecrets;
/**
 * monitorSupportsResourceReferences returns a promise that when resolved tells you if the resource monitor we are
 * connected to is able to support resouece references aross its RPC interface. When it does, we marshal resources
 * in a special way.
 */
function monitorSupportsResourceReferences() {
    return __awaiter(this, void 0, void 0, function* () {
        return monitorSupportsFeature("resourceReferences");
    });
}
exports.monitorSupportsResourceReferences = monitorSupportsResourceReferences;
