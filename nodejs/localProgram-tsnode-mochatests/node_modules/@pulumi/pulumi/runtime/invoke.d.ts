import { AsyncIterable } from "@pulumi/query/interfaces";
import { InvokeOptions } from "../invoke";
import { Inputs } from "../output";
/**
 * `invoke` dynamically invokes the function, `tok`, which is offered by a provider plugin. `invoke`
 * behaves differently in the case that options contains `{async:true}` or not.
 *
 * In the case where `{async:true}` is present in the options bag:
 *
 * 1. the result of `invoke` will be a Promise resolved to the result value of the provider plugin.
 * 2. the `props` inputs can be a bag of computed values (including, `T`s, `Promise<T>`s,
 *    `Output<T>`s etc.).
 *
 *
 * In the case where `{async:true}` is not present in the options bag:
 *
 * 1. the result of `invoke` will be a Promise resolved to the result value of the provider call.
 *    However, that Promise will *also* have the respective values of the Provider result exposed
 *    directly on it as properties.
 *
 * 2. The inputs must be a bag of simple values, and the result is the result that the Provider
 *    produced.
 *
 * Simple values are:
 *  1. `undefined`, `null`, string, number or boolean values.
 *  2. arrays of simple values.
 *  3. objects containing only simple values.
 *
 * Importantly, simple values do *not* include:
 *  1. `Promise`s
 *  2. `Output`s
 *  3. `Asset`s or `Archive`s
 *  4. `Resource`s.
 *
 * All of these contain async values that would prevent `invoke from being able to operate
 * synchronously.
 */
export declare function invoke(tok: string, props: Inputs, opts?: InvokeOptions): Promise<any>;
export declare function streamInvoke(tok: string, props: Inputs, opts?: InvokeOptions): Promise<StreamInvokeResponse<any>>;
export declare class StreamInvokeResponse<T> implements AsyncIterable<T> {
    private source;
    private cancelSource;
    constructor(source: AsyncIterable<T>, cancelSource: () => void);
    cancel(): void;
    [Symbol.asyncIterator](): import("@pulumi/query/interfaces").AsyncIterator<T>;
}
