import { ComponentResource, URN } from "../resource";
export declare const maxRPCMessageSize: number;
/**
 * excessiveDebugOutput enables, well, pretty excessive debug output pertaining to resources and properties.
 */
export declare let excessiveDebugOutput: boolean;
/**
 * Options is a bag of settings that controls the behavior of previews and deployments
 */
export interface Options {
    readonly project?: string;
    readonly stack?: string;
    readonly parallel?: number;
    readonly engineAddr?: string;
    readonly monitorAddr?: string;
    readonly dryRun?: boolean;
    readonly testModeEnabled?: boolean;
    readonly queryMode?: boolean;
    readonly legacyApply?: boolean;
    /**
     * Directory containing the send/receive files for making synchronous invokes to the engine.
     */
    readonly syncDir?: string;
}
export declare function resetOptions(project: string, stack: string, parallel: number, engineAddr: string, monitorAddr: string, preview: boolean): void;
export declare function setMockOptions(mockMonitor: any, project?: string, stack?: string, preview?: boolean): void;
/**
 * Returns true if we're currently performing a dry-run, or false if this is a true update. Note that we
 * always consider executions in test mode to be "dry-runs", since we will never actually carry out an update,
 * and therefore certain output properties will never be resolved.
 */
export declare function isDryRun(): boolean;
/**
 * Returns true if test mode is enabled (PULUMI_TEST_MODE).
 */
export declare function isTestModeEnabled(): boolean;
/**
 * Returns true if query mode is enabled.
 */
export declare function isQueryMode(): boolean;
/**
 * Returns true if we will resolve missing outputs to inputs during preview (PULUMI_ENABLE_LEGACY_APPLY).
 */
export declare function isLegacyApplyEnabled(): boolean;
/**
 * Get the project being run by the current update.
 */
export declare function getProject(): string;
/**
 * Get the stack being targeted by the current update.
 */
export declare function getStack(): string;
/**
 * hasMonitor returns true if we are currently connected to a resource monitoring service.
 */
export declare function hasMonitor(): boolean;
/**
 * getMonitor returns the current resource monitoring service client for RPC communications.
 */
export declare function getMonitor(): Object | undefined;
/**
 * hasEngine returns true if we are currently connected to an engine.
 */
export declare function hasEngine(): boolean;
/**
 * getEngine returns the current engine, if any, for RPC communications back to the resource engine.
 */
export declare function getEngine(): Object | undefined;
export declare function terminateRpcs(): void;
/**
 * serialize returns true if resource operations should be serialized.
 */
export declare function serialize(): boolean;
/**
 * disconnect permanently disconnects from the server, closing the connections.  It waits for the existing RPC
 * queue to drain.  If any RPCs come in afterwards, however, they will crash the process.
 */
export declare function disconnect(): Promise<void>;
/**
 * disconnectSync permanently disconnects from the server, closing the connections. Unlike `disconnect`. it does not
 * wait for the existing RPC queue to drain. Any RPCs that come in after this call will crash the process.
 */
export declare function disconnectSync(): void;
/**
 * rpcKeepAlive registers a pending call to ensure that we don't prematurely disconnect from the server.  It returns
 * a function that, when invoked, signals that the RPC has completed.
 */
export declare function rpcKeepAlive(): () => void;
/**
 * getRootResource returns a root resource URN that will automatically become the default parent of all resources.  This
 * can be used to ensure that all resources without explicit parents are parented to a common parent resource.
 */
export declare function getRootResource(): Promise<URN | undefined>;
/**
 * setRootResource registers a resource that will become the default parent for all resources without explicit parents.
 */
export declare function setRootResource(res: ComponentResource): Promise<void>;
/**
 * monitorSupportsFeature returns a promise that when resolved tells you if the resource monitor we are connected
 * to is able to support a particular feature.
 */
export declare function monitorSupportsFeature(feature: string): Promise<boolean>;
/**
 * monitorSupportsSecrets returns a promise that when resolved tells you if the resource monitor we are connected
 * to is able to support secrets across its RPC interface. When it does, we marshal outputs marked with the secret
 * bit in a special way.
 */
export declare function monitorSupportsSecrets(): Promise<boolean>;
/**
 * monitorSupportsResourceReferences returns a promise that when resolved tells you if the resource monitor we are
 * connected to is able to support resouece references aross its RPC interface. When it does, we marshal resources
 * in a special way.
 */
export declare function monitorSupportsResourceReferences(): Promise<boolean>;
