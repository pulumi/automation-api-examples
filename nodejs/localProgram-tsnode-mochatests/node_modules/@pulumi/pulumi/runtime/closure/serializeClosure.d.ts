import { Resource } from "../../resource";
/**
 * SerializeFunctionArgs are arguments used to serialize a JavaScript function
 */
export interface SerializeFunctionArgs {
    /**
     * The name to export from the module defined by the generated module text.  Defaults to 'handler'.
     */
    exportName?: string;
    /**
     * A function to prevent serialization of certain objects captured during the serialization.  Primarily used to
     * prevent potential cycles.
     */
    serialize?: (o: any) => boolean;
    /**
     * If this is a function which, when invoked, will produce the actual entrypoint function.
     * Useful for when serializing a function that has high startup cost that only wants to be
     * run once. The signature of this function should be:  () => (provider_handler_args...) => provider_result
     *
     * This will then be emitted as: `exports.[exportName] = serialized_func_name();`
     *
     * In other words, the function will be invoked (once) and the resulting inner function will
     * be what is exported.
     */
    isFactoryFunction?: boolean;
    /**
     * The resource to log any errors we encounter against.
     */
    logResource?: Resource;
}
/**
 * SerializeFunction is a representation of a serialized JavaScript function.
 */
export interface SerializedFunction {
    /**
     * The text of a JavaScript module which exports a single name bound to an appropriate value.
     * In the case of a normal function, this value will just be serialized function.  In the case
     * of a factory function this value will be the result of invoking the factory function.
     */
    text: string;
    /**
     * The name of the exported module member.
     */
    exportName: string;
}
/**
 * serializeFunction serializes a JavaScript function into a text form that can be loaded in another execution context,
 * for example as part of a function callback associated with an AWS Lambda.  The function serialization captures any
 * variables captured by the function body and serializes those values into the generated text along with the function
 * body.  This process is recursive, so that functions referenced by the body of the serialized function will themselves
 * be serialized as well.  This process also deeply serializes captured object values, including prototype chains and
 * property descriptors, such that the semantics of the function when deserialized should match the original function.
 *
 * There are several known limitations:
 * - If a native function is captured either directly or indirectly, closure serialization will return an error.
 * - Captured values will be serialized based on their values at the time that `serializeFunction` is called.  Mutations
 *   to these values after that (but before the deserialized function is used) will not be observed by the deserialized
 *   function.
 *
 * @param func The JavaScript function to serialize.
 * @param args Arguments to use to control the serialization of the JavaScript function.
 */
export declare function serializeFunction(func: Function, args?: SerializeFunctionArgs): Promise<SerializedFunction>;
/**
 * @deprecated Please use 'serializeFunction' instead.
 */
export declare function serializeFunctionAsync(func: Function, serialize?: (o: any) => boolean): Promise<string>;
