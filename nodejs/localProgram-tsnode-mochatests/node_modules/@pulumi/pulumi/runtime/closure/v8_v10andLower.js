"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const semver = require("semver");
const isNodeAtLeastV10 = semver.gte(process.version, "10.0.0");
// `GetFunctionScopeDetails` returns a raw JavaScript array. This enum enumerates the objects that
// are at specific indices of the array. We only care about one of these.
var V8ScopeDetailsFields;
(function (V8ScopeDetailsFields) {
    V8ScopeDetailsFields[V8ScopeDetailsFields["kScopeDetailsTypeIndex"] = 0] = "kScopeDetailsTypeIndex";
    V8ScopeDetailsFields[V8ScopeDetailsFields["kScopeDetailsObjectIndex"] = 1] = "kScopeDetailsObjectIndex";
    V8ScopeDetailsFields[V8ScopeDetailsFields["kScopeDetailsNameIndex"] = 2] = "kScopeDetailsNameIndex";
    V8ScopeDetailsFields[V8ScopeDetailsFields["kScopeDetailsStartPositionIndex"] = 3] = "kScopeDetailsStartPositionIndex";
    V8ScopeDetailsFields[V8ScopeDetailsFields["kScopeDetailsEndPositionIndex"] = 4] = "kScopeDetailsEndPositionIndex";
    V8ScopeDetailsFields[V8ScopeDetailsFields["kScopeDetailsFunctionIndex"] = 5] = "kScopeDetailsFunctionIndex";
})(V8ScopeDetailsFields || (V8ScopeDetailsFields = {}));
/** @internal */
function getFunctionLocationAsync(func) {
    return __awaiter(this, void 0, void 0, function* () {
        const script = getScript(func);
        const { line, column } = getLineColumn();
        return { file: script ? script.name : "", line, column };
        function getLineColumn() {
            if (script) {
                const pos = getSourcePosition(func);
                try {
                    if (isNodeAtLeastV10) {
                        return scriptPositionInfo(script, pos);
                    }
                    else {
                        return script.locationFromPosition(pos);
                    }
                }
                catch (err) {
                    // Be resilient to native functions not being available. In this case, we just return
                    // '0,0'.  That's not great, but it at least lets us run, and it isn't a terrible
                    // experience.
                    //
                    // Specifically, we only need these locations when we're printing out an error about not
                    // being able to serialize something.  In that case, we still print out the names of the
                    // functions (as well as the call-tree that got us there), *and* we print out the body
                    // of the function.  With both of these, it is generally not too difficult to find out
                    // where the code actually lives.
                }
            }
            return { line: 0, column: 0 };
        }
    });
}
exports.getFunctionLocationAsync = getFunctionLocationAsync;
function getScript(func) {
    // The use of the Function constructor here and elsewhere in this file is because
    // because V8 intrinsics are not valid JavaScript identifiers; they all begin with '%',
    // which means that the TypeScript compiler issues errors for them.
    const scriptFunc = new Function("func", "return %FunctionGetScript(func);");
    return scriptFunc(func);
}
// The second intrinsic is `FunctionGetScriptSourcePosition`, which does about what you'd
// expect. It returns a `V8SourcePosition`, which can be passed to `V8Script::locationFromPosition`
// to produce a `V8SourceLocation`.
const getSourcePosition = new Function("func", "return %FunctionGetScriptSourcePosition(func);");
function scriptPositionInfo(script, pos) {
    if (isNodeAtLeastV10) {
        const scriptPositionInfoFunc = new Function("script", "pos", "return %ScriptPositionInfo(script, pos, false);");
        return scriptPositionInfoFunc(script, pos);
    }
    // Should not be called if running on Node<10.0.0.
    return undefined;
}
/** @internal */
function lookupCapturedVariableValueAsync(func, freeVariable, throwOnFailure) {
    return __awaiter(this, void 0, void 0, function* () {
        // The implementation of this function is now very straightforward since the intrinsics do all of the
        // difficult work.
        const count = getFunctionScopeCount(func);
        for (let i = 0; i < count; i++) {
            const scope = getScopeForFunction(func, i);
            if (freeVariable in scope.scopeObject) {
                return scope.scopeObject[freeVariable];
            }
        }
        if (throwOnFailure) {
            throw new Error("Unexpected missing variable in closure environment: " + freeVariable);
        }
        return undefined;
    });
}
exports.lookupCapturedVariableValueAsync = lookupCapturedVariableValueAsync;
// The last two intrinsics are `GetFunctionScopeCount` and `GetFunctionScopeDetails`.
// The former function returns the number of scopes in a given function's scope chain, while
// the latter function returns the i'th entry in a function's scope chain, given a function and
// index i.
function getFunctionScopeDetails(func, index) {
    const getFunctionScopeDetailsFunc = new Function("func", "index", "return %GetFunctionScopeDetails(func, index);");
    return getFunctionScopeDetailsFunc(func, index);
}
function getFunctionScopeCount(func) {
    const getFunctionScopeCountFunc = new Function("func", "return %GetFunctionScopeCount(func);");
    return getFunctionScopeCountFunc(func);
}
// getScopeForFunction extracts a V8ScopeDetails for the index'th element in the scope chain for the
// given function.
function getScopeForFunction(func, index) {
    const scopeDetails = getFunctionScopeDetails(func, index);
    return {
        scopeObject: scopeDetails[V8ScopeDetailsFields.kScopeDetailsObjectIndex],
    };
}
// All of these functions contain syntax that is not legal TS/JS (i.e. "%Whatever").  As such,
// we cannot serialize them.  In case they somehow get captured, just block them from closure
// serialization entirely.
getScript.doNotCapture = true;
getSourcePosition.doNotCapture = true;
getFunctionScopeDetails.doNotCapture = true;
getFunctionScopeCount.doNotCapture = true;
