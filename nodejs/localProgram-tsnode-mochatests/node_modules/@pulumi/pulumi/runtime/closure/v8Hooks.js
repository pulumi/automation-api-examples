"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// Module that hooks into v8 and provides information about it to interested parties. Because this
// hooks into v8 events it is critical that this module is loaded early when the process starts.
// Otherwise, information may not be known when needed.  This module is only intended for use on
// Node v11 and higher.
const v8 = require("v8");
v8.setFlagsFromString("--allow-natives-syntax");
const semver = require("semver");
// On node11 and above, create an 'inspector session' that can be used to keep track of what is
// happening through a supported API.  Pre-11 we can just call into % intrinsics for the same data.
/** @internal */
exports.isNodeAtLeastV11 = semver.gte(process.version, "11.0.0");
const session = exports.isNodeAtLeastV11
    ? createInspectorSessionAsync()
    : Promise.resolve(undefined);
const scriptIdToUrlMap = new Map();
function createInspectorSessionAsync() {
    return __awaiter(this, void 0, void 0, function* () {
        // Delay loading 'inspector' as it is not available on early versions of node, so we can't
        // require it on the outside.
        const inspector = yield Promise.resolve().then(() => require("inspector"));
        const inspectorSession = new inspector.Session();
        inspectorSession.connect();
        // Enable debugging support so we can hear about the Debugger.scriptParsed event. We need that
        // event to know how to map from scriptId's to file-urls.
        yield new Promise((resolve, reject) => {
            inspectorSession.post("Debugger.enable", (err, res) => err ? reject(err) : resolve(res));
        });
        inspectorSession.addListener("Debugger.scriptParsed", event => {
            const { scriptId, url } = event.params;
            scriptIdToUrlMap.set(scriptId, url);
        });
        return inspectorSession;
    });
}
/**
 * Returns the inspector session that can be used to query the state of this running Node instance.
 * Must only be called on Node11 and above. On Node10 and below, this will throw.
 * @internal
 */
function getSessionAsync() {
    return __awaiter(this, void 0, void 0, function* () {
        if (!exports.isNodeAtLeastV11) {
            throw new Error("Should not call getSessionAsync unless on Node11 or above.");
        }
        return session;
    });
}
exports.getSessionAsync = getSessionAsync;
/**
 * Returns a promise that can be used to determine when the v8hooks have been injected properly and
 * code that depends on them can continue executing.
 * @internal
 */
function isInitializedAsync() {
    return __awaiter(this, void 0, void 0, function* () {
        yield session;
    });
}
exports.isInitializedAsync = isInitializedAsync;
/**
 * Maps from a script-id to the local file url it corresponds to.
 * @internal
 */
function getScriptUrl(id) {
    return scriptIdToUrlMap.get(id);
}
exports.getScriptUrl = getScriptUrl;
