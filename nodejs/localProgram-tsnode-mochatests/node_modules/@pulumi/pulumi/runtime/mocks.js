"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const rpc_1 = require("./rpc");
const settings_1 = require("./settings");
const provproto = require("../proto/provider_pb.js");
const resproto = require("../proto/resource_pb.js");
const structproto = require("google-protobuf/google/protobuf/struct_pb.js");
class MockMonitor {
    constructor(mocks) {
        this.mocks = mocks;
        this.resources = new Map();
    }
    newUrn(parent, type, name) {
        if (parent) {
            const qualifiedType = parent.split("::")[2];
            const parentType = qualifiedType.split("$").pop();
            type = parentType + "$" + type;
        }
        return "urn:pulumi:" + [settings_1.getStack(), settings_1.getProject(), type, name].join("::");
    }
    invoke(req, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const tok = req.getTok();
                const inputs = rpc_1.deserializeProperties(req.getArgs());
                if (tok === "pulumi:pulumi:getResource") {
                    const registeredResource = this.resources.get(inputs.urn);
                    if (!registeredResource) {
                        throw new Error(`unknown resource ${inputs.urn}`);
                    }
                    const resp = new provproto.InvokeResponse();
                    resp.setReturn(structproto.Struct.fromJavaScript(registeredResource));
                    callback(null, resp);
                    return;
                }
                const result = this.mocks.call(tok, inputs, req.getProvider());
                const response = new provproto.InvokeResponse();
                response.setReturn(structproto.Struct.fromJavaScript(yield rpc_1.serializeProperties("", result)));
                callback(null, response);
            }
            catch (err) {
                callback(err, undefined);
            }
        });
    }
    readResource(req, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const result = this.mocks.newResource(req.getType(), req.getName(), rpc_1.deserializeProperties(req.getProperties()), req.getProvider(), req.getId());
                const urn = this.newUrn(req.getParent(), req.getType(), req.getName());
                const serializedState = yield rpc_1.serializeProperties("", result.state);
                this.resources.set(urn, { urn, id: result.id, state: serializedState });
                const response = new resproto.ReadResourceResponse();
                response.setUrn(urn);
                response.setProperties(structproto.Struct.fromJavaScript(serializedState));
                callback(null, response);
            }
            catch (err) {
                callback(err, undefined);
            }
        });
    }
    registerResource(req, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const result = this.mocks.newResource(req.getType(), req.getName(), rpc_1.deserializeProperties(req.getObject()), req.getProvider(), req.getImportid());
                const urn = this.newUrn(req.getParent(), req.getType(), req.getName());
                const serializedState = yield rpc_1.serializeProperties("", result.state);
                this.resources.set(urn, { urn, id: result.id, state: serializedState });
                const response = new resproto.RegisterResourceResponse();
                response.setUrn(urn);
                response.setId(result.id);
                response.setObject(structproto.Struct.fromJavaScript(serializedState));
                callback(null, response);
            }
            catch (err) {
                callback(err, undefined);
            }
        });
    }
    registerResourceOutputs(req, callback) {
        callback(null, {});
    }
    supportsFeature(req, callback) {
        callback(null, {
            getHassupport: () => true,
        });
    }
}
exports.MockMonitor = MockMonitor;
/**
 * setMocks configures the Pulumi runtime to use the given mocks for testing.
 *
 * @param mocks: The mocks to use for calls to provider functions and resource consrtuction.
 * @param project: If provided, the name of the Pulumi project. Defaults to "project".
 * @param stack: If provided, the name of the Pulumi stack. Defaults to "stack".
 * @param preview: If provided, indicates whether or not the program is running a preview. Defaults to false.
 */
function setMocks(mocks, project, stack, preview) {
    settings_1.setMockOptions(new MockMonitor(mocks), project, stack, preview);
}
exports.setMocks = setMocks;
