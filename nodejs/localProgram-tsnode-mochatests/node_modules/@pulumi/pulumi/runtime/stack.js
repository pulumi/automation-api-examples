"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const asset = require("../asset");
const metadata_1 = require("../metadata");
const output_1 = require("../output");
const resource_1 = require("../resource");
const settings_1 = require("./settings");
/**
 * rootPulumiStackTypeName is the type name that should be used to construct the root component in the tree of Pulumi
 * resources allocated by a deployment.  This must be kept up to date with
 * `github.com/pulumi/pulumi/pkg/v2/resource/stack.RootPulumiStackTypeName`.
 */
exports.rootPulumiStackTypeName = "pulumi:pulumi:Stack";
let stackResource;
// Get the root stack resource for the current stack deployment
function getStackResource() {
    return stackResource;
}
exports.getStackResource = getStackResource;
/**
 * runInPulumiStack creates a new Pulumi stack resource and executes the callback inside of it.  Any outputs
 * returned by the callback will be stored as output properties on this resulting Stack object.
 */
function runInPulumiStack(init) {
    if (!settings_1.isQueryMode()) {
        const stack = new Stack(init);
        return stack.outputs.promise();
    }
    else {
        return init();
    }
}
exports.runInPulumiStack = runInPulumiStack;
/**
 * Stack is the root resource for a Pulumi stack. Before invoking the `init` callback, it registers itself as the root
 * resource with the Pulumi engine.
 */
class Stack extends resource_1.ComponentResource {
    constructor(init) {
        super(exports.rootPulumiStackTypeName, `${metadata_1.getProject()}-${metadata_1.getStack()}`, { init });
        const data = this.getData();
        this.outputs = output_1.output(data);
    }
    /**
     * runInit invokes the given init callback with this resource set as the root resource. The return value of init is
     * used as the stack's output properties.
     *
     * @param init The callback to run in the context of this Pulumi stack
     */
    initialize(args) {
        const _super = Object.create(null, {
            registerOutputs: { get: () => super.registerOutputs }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const parent = yield settings_1.getRootResource();
            if (parent) {
                throw new Error("Only one root Pulumi Stack may be active at once");
            }
            yield settings_1.setRootResource(this);
            // Set the global reference to the stack resource before invoking this init() function
            stackResource = this;
            let outputs;
            try {
                const inputs = yield args.init();
                outputs = yield massage(inputs, []);
            }
            finally {
                // We want to expose stack outputs as simple pojo objects (including Resources).  This
                // helps ensure that outputs can point to resources, and that that is stored and
                // presented as something reasonable, and not as just an id/urn in the case of
                // Resources.
                _super.registerOutputs.call(this, outputs);
            }
            return outputs;
        });
    }
}
function massage(prop, objectStack) {
    return __awaiter(this, void 0, void 0, function* () {
        if (prop === undefined ||
            prop === null ||
            typeof prop === "boolean" ||
            typeof prop === "number" ||
            typeof prop === "string") {
            return prop;
        }
        if (prop instanceof Promise) {
            return yield massage(yield prop, objectStack);
        }
        if (output_1.Output.isInstance(prop)) {
            const result = prop.apply(v => massage(v, objectStack));
            // explicitly await the underlying promise of the output here.  This is necessary to get a
            // deterministic walk of the object graph.  We need that deterministic walk, otherwise our
            // actual cycle detection logic (using 'objectStack') doesn't work.  i.e. if we don't do
            // this then the main walking logic will be interleaved with the async function this output
            // is executing.  This interleaving breaks out assumption about pushing/popping values onto
            // objectStack'
            yield result.promise();
            return result;
        }
        // from this point on, we have complex objects.  If we see them again, we don't want to emit
        // them again fully or else we'd loop infinitely.
        if (objectStack.indexOf(prop) >= 0) {
            // Note: for Resources we hit again, emit their urn so cycles can be easily understood
            // in the pojo objects.
            if (resource_1.Resource.isInstance(prop)) {
                return yield massage(prop.urn, objectStack);
            }
            return undefined;
        }
        try {
            // push and pop what we see into a stack.  That way if we see the same object through
            // different paths, we will still print it out.  We only skip it if it would truly cause
            // recursion.
            objectStack.push(prop);
            return yield massageComplex(prop, objectStack);
        }
        finally {
            const popped = objectStack.pop();
            if (popped !== prop) {
                throw new Error("Invariant broken when processing stack outputs");
            }
        }
    });
}
function massageComplex(prop, objectStack) {
    return __awaiter(this, void 0, void 0, function* () {
        if (asset.Asset.isInstance(prop)) {
            if (prop.path !== undefined) {
                return { path: prop.path };
            }
            else if (prop.uri !== undefined) {
                return { uri: prop.uri };
            }
            else if (prop.text !== undefined) {
                return { text: "..." };
            }
            return undefined;
        }
        if (asset.Archive.isInstance(prop)) {
            if (prop.assets) {
                return { assets: yield massage(prop.assets, objectStack) };
            }
            else if (prop.path !== undefined) {
                return { path: prop.path };
            }
            else if (prop.uri !== undefined) {
                return { uri: prop.uri };
            }
            return undefined;
        }
        if (resource_1.Resource.isInstance(prop)) {
            // Emit a resource as a normal pojo.  But filter out all our internal properties so that
            // they don't clutter the display/checkpoint with values not relevant to the application.
            //
            // In preview only, we mark the POJO with "@isPulumiResource" to indicate that it is derived
            // from a resource. This allows the engine to perform resource-specific filtering of unknowns
            // from output diffs during a preview. This filtering is not necessary during an update because
            // all property values are known.
            const pojo = yield serializeAllKeys(n => !n.startsWith("__"));
            return !settings_1.isDryRun() ? pojo : Object.assign(Object.assign({}, pojo), { "@isPulumiResource": true });
        }
        if (prop instanceof Array) {
            const result = [];
            for (let i = 0; i < prop.length; i++) {
                result[i] = yield massage(prop[i], objectStack);
            }
            return result;
        }
        return yield serializeAllKeys(n => true);
        function serializeAllKeys(include) {
            return __awaiter(this, void 0, void 0, function* () {
                const obj = {};
                for (const k of Object.keys(prop)) {
                    if (include(k)) {
                        obj[k] = yield massage(prop[k], objectStack);
                    }
                }
                return obj;
            });
        }
    });
}
/**
 * Add a transformation to all future resources constructed in this Pulumi stack.
 */
function registerStackTransformation(t) {
    if (!stackResource) {
        throw new Error("The root stack resource was referenced before it was initialized.");
    }
    stackResource.__transformations = [...(stackResource.__transformations || []), t];
}
exports.registerStackTransformation = registerStackTransformation;
