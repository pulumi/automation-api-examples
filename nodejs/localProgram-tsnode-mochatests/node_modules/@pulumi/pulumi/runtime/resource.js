"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const grpc = require("@grpc/grpc-js");
const query = require("@pulumi/query");
const log = require("../log");
const utils = require("../utils");
const output_1 = require("../output");
const resource_1 = require("../resource");
const debuggable_1 = require("./debuggable");
const invoke_1 = require("./invoke");
const rpc_1 = require("./rpc");
const settings_1 = require("./settings");
const gstruct = require("google-protobuf/google/protobuf/struct_pb.js");
const providerproto = require("../proto/provider_pb.js");
const resproto = require("../proto/resource_pb.js");
/**
 * Get an existing resource's state from the engine.
 */
function getResource(res, props, custom, urn) {
    // Extract the resource type from the URN.
    const urnParts = urn.split("::");
    const qualifiedType = urnParts[2];
    const urnName = urnParts[3];
    const type = qualifiedType.split("$").pop();
    const label = `resource:urn=${urn}`;
    log.debug(`Getting resource: urn=${urn}`);
    const monitor = settings_1.getMonitor();
    const resopAsync = prepareResource(label, res, custom, props, {});
    const preallocError = new Error();
    debuggable_1.debuggablePromise(resopAsync.then((resop) => __awaiter(this, void 0, void 0, function* () {
        const inputs = yield rpc_1.serializeProperties(label, { urn });
        const req = new providerproto.InvokeRequest();
        req.setTok("pulumi:pulumi:getResource");
        req.setArgs(gstruct.Struct.fromJavaScript(inputs));
        req.setProvider("");
        req.setVersion("");
        // Now run the operation, serializing the invocation if necessary.
        const opLabel = `monitor.getResource(${label})`;
        runAsyncResourceOp(opLabel, () => __awaiter(this, void 0, void 0, function* () {
            let resp;
            let err;
            try {
                if (monitor) {
                    resp = yield debuggable_1.debuggablePromise(new Promise((resolve, reject) => monitor.invoke(req, (rpcError, innerResponse) => {
                        log.debug(`getResource Invoke RPC finished: err: ${rpcError}, resp: ${innerResponse}`);
                        if (rpcError) {
                            if (rpcError.code === grpc.status.UNAVAILABLE || rpcError.code === grpc.status.CANCELLED) {
                                err = rpcError;
                                settings_1.terminateRpcs();
                                rpcError.message = "Resource monitor is terminating";
                                preallocError.code = rpcError.code;
                            }
                            preallocError.message = `failed to get resource:urn=${urn}: ${rpcError.message}`;
                            reject(new Error(rpcError.details));
                        }
                        else {
                            resolve(innerResponse);
                        }
                    })), opLabel);
                    // If the invoke failed, raise an error
                    const failures = resp.getFailuresList();
                    if (failures && failures.length) {
                        let reasons = "";
                        for (let i = 0; i < failures.length; i++) {
                            if (reasons !== "") {
                                reasons += "; ";
                            }
                            reasons += `${failures[i].getReason()} (${failures[i].getProperty()})`;
                        }
                        throw new Error(`getResource Invoke failed: ${reasons}`);
                    }
                    // Otherwise, return the response.
                    const m = resp.getReturn().getFieldsMap();
                    resp = {
                        urn: m.get("urn").toJavaScript(),
                        id: m.get("id").toJavaScript() || undefined,
                        state: m.get("state").getStructValue(),
                    };
                }
            }
            catch (e) {
                err = e;
                resp = {
                    urn: "",
                    id: undefined,
                    state: undefined,
                };
            }
            resop.resolveURN(resp.urn, err);
            // Note: 'id || undefined' is intentional.  We intentionally collapse falsy values to
            // undefined so that later parts of our system don't have to deal with values like 'null'.
            if (resop.resolveID) {
                const id = resp.id || undefined;
                resop.resolveID(id, id !== undefined, err);
            }
            yield resolveOutputs(res, type, urnName, props, resp.state, {}, resop.resolvers, err);
        }));
    })), label);
}
exports.getResource = getResource;
/**
 * Reads an existing custom resource's state from the resource monitor.  Note that resources read in this way
 * will not be part of the resulting stack's state, as they are presumed to belong to another.
 */
function readResource(res, t, name, props, opts) {
    const id = opts.id;
    if (!id) {
        throw new Error("Cannot read resource whose options are lacking an ID value");
    }
    const label = `resource:${name}[${t}]#...`;
    log.debug(`Reading resource: id=${output_1.Output.isInstance(id) ? "Output<T>" : id}, t=${t}, name=${name}`);
    const monitor = settings_1.getMonitor();
    const resopAsync = prepareResource(label, res, true, props, opts);
    const preallocError = new Error();
    debuggable_1.debuggablePromise(resopAsync.then((resop) => __awaiter(this, void 0, void 0, function* () {
        const resolvedID = yield rpc_1.serializeProperty(label, id, new Set());
        log.debug(`ReadResource RPC prepared: id=${resolvedID}, t=${t}, name=${name}` +
            (settings_1.excessiveDebugOutput ? `, obj=${JSON.stringify(resop.serializedProps)}` : ``));
        // Create a resource request and do the RPC.
        const req = new resproto.ReadResourceRequest();
        req.setType(t);
        req.setName(name);
        req.setId(resolvedID);
        req.setParent(resop.parentURN);
        req.setProvider(resop.providerRef);
        req.setProperties(gstruct.Struct.fromJavaScript(resop.serializedProps));
        req.setDependenciesList(Array.from(resop.allDirectDependencyURNs));
        req.setVersion(opts.version || "");
        req.setAcceptsecrets(true);
        req.setAcceptresources(!utils.disableResourceReferences);
        req.setAdditionalsecretoutputsList(opts.additionalSecretOutputs || []);
        // Now run the operation, serializing the invocation if necessary.
        const opLabel = `monitor.readResource(${label})`;
        runAsyncResourceOp(opLabel, () => __awaiter(this, void 0, void 0, function* () {
            let resp;
            let err;
            try {
                if (monitor) {
                    // If we're attached to the engine, make an RPC call and wait for it to resolve.
                    resp = yield debuggable_1.debuggablePromise(new Promise((resolve, reject) => monitor.readResource(req, (rpcError, innerResponse) => {
                        log.debug(`ReadResource RPC finished: ${label}; err: ${rpcError}, resp: ${innerResponse}`);
                        if (rpcError) {
                            if (rpcError.code === grpc.status.UNAVAILABLE || rpcError.code === grpc.status.CANCELLED) {
                                err = rpcError;
                                settings_1.terminateRpcs();
                                rpcError.message = "Resource monitor is terminating";
                                preallocError.code = rpcError.code;
                            }
                            preallocError.message =
                                `failed to read resource #${resolvedID} '${name}' [${t}]: ${rpcError.message}`;
                            reject(preallocError);
                        }
                        else {
                            resolve(innerResponse);
                        }
                    })), opLabel);
                }
                else {
                    // If we aren't attached to the engine, in test mode, mock up a fake response for testing purposes.
                    const mockurn = yield resource_1.createUrn(req.getName(), req.getType(), req.getParent()).promise();
                    resp = {
                        getUrn: () => mockurn,
                        getProperties: () => req.getProperties(),
                    };
                }
            }
            catch (e) {
                err = e;
                resp = {
                    getUrn: () => "",
                    getProperties: () => undefined,
                };
            }
            // Now resolve everything: the URN, the ID (supplied as input), and the output properties.
            resop.resolveURN(resp.getUrn(), err);
            resop.resolveID(resolvedID, resolvedID !== undefined, err);
            yield resolveOutputs(res, t, name, props, resp.getProperties(), {}, resop.resolvers, err);
        }));
    })), label);
}
exports.readResource = readResource;
/**
 * registerResource registers a new resource object with a given type t and name.  It returns the auto-generated
 * URN and the ID that will resolve after the deployment has completed.  All properties will be initialized to property
 * objects that the registration operation will resolve at the right time (or remain unresolved for deployments).
 */
function registerResource(res, t, name, custom, remote, newDependency, props, opts) {
    const label = `resource:${name}[${t}]`;
    log.debug(`Registering resource: t=${t}, name=${name}, custom=${custom}, remote=${remote}`);
    const monitor = settings_1.getMonitor();
    const resopAsync = prepareResource(label, res, custom, props, opts);
    // In order to present a useful stack trace if an error does occur, we preallocate potential
    // errors here. V8 captures a stack trace at the moment an Error is created and this stack
    // trace will lead directly to user code. Throwing in `runAsyncResourceOp` results in an Error
    // with a non-useful stack trace.
    const preallocError = new Error();
    debuggable_1.debuggablePromise(resopAsync.then((resop) => __awaiter(this, void 0, void 0, function* () {
        log.debug(`RegisterResource RPC prepared: t=${t}, name=${name}` +
            (settings_1.excessiveDebugOutput ? `, obj=${JSON.stringify(resop.serializedProps)}` : ``));
        const req = new resproto.RegisterResourceRequest();
        req.setType(t);
        req.setName(name);
        req.setParent(resop.parentURN);
        req.setCustom(custom);
        req.setObject(gstruct.Struct.fromJavaScript(resop.serializedProps));
        req.setProtect(opts.protect);
        req.setProvider(resop.providerRef);
        req.setDependenciesList(Array.from(resop.allDirectDependencyURNs));
        req.setDeletebeforereplace(opts.deleteBeforeReplace || false);
        req.setDeletebeforereplacedefined(opts.deleteBeforeReplace !== undefined);
        req.setIgnorechangesList(opts.ignoreChanges || []);
        req.setVersion(opts.version || "");
        req.setAcceptsecrets(true);
        req.setAcceptresources(!utils.disableResourceReferences);
        req.setAdditionalsecretoutputsList(opts.additionalSecretOutputs || []);
        req.setAliasesList(resop.aliases);
        req.setImportid(resop.import || "");
        req.setSupportspartialvalues(true);
        req.setRemote(remote);
        const customTimeouts = new resproto.RegisterResourceRequest.CustomTimeouts();
        if (opts.customTimeouts != null) {
            customTimeouts.setCreate(opts.customTimeouts.create);
            customTimeouts.setUpdate(opts.customTimeouts.update);
            customTimeouts.setDelete(opts.customTimeouts.delete);
        }
        req.setCustomtimeouts(customTimeouts);
        const propertyDependencies = req.getPropertydependenciesMap();
        for (const [key, resourceURNs] of resop.propertyToDirectDependencyURNs) {
            const deps = new resproto.RegisterResourceRequest.PropertyDependencies();
            deps.setUrnsList(Array.from(resourceURNs));
            propertyDependencies.set(key, deps);
        }
        // Now run the operation, serializing the invocation if necessary.
        const opLabel = `monitor.registerResource(${label})`;
        runAsyncResourceOp(opLabel, () => __awaiter(this, void 0, void 0, function* () {
            let resp;
            let err;
            try {
                if (monitor) {
                    // If we're running with an attachment to the engine, perform the operation.
                    resp = yield debuggable_1.debuggablePromise(new Promise((resolve, reject) => monitor.registerResource(req, (rpcErr, innerResponse) => {
                        if (rpcErr) {
                            err = rpcErr;
                            // If the monitor is unavailable, it is in the process of shutting down or has already
                            // shut down. Don't emit an error and don't do any more RPCs, just exit.
                            if (rpcErr.code === grpc.status.UNAVAILABLE || rpcErr.code === grpc.status.CANCELLED) {
                                // Re-emit the message
                                settings_1.terminateRpcs();
                                rpcErr.message = "Resource monitor is terminating";
                                preallocError.code = rpcErr.code;
                            }
                            // Node lets us hack the message as long as we do it before accessing the `stack` property.
                            log.debug(`RegisterResource RPC finished: ${label}; err: ${rpcErr}, resp: ${innerResponse}`);
                            preallocError.message = `failed to register new resource ${name} [${t}]: ${rpcErr.message}`;
                            reject(preallocError);
                        }
                        else {
                            log.debug(`RegisterResource RPC finished: ${label}; err: ${rpcErr}, resp: ${innerResponse}`);
                            resolve(innerResponse);
                        }
                    })), opLabel);
                }
                else {
                    // If we aren't attached to the engine, in test mode, mock up a fake response for testing purposes.
                    const mockurn = yield resource_1.createUrn(req.getName(), req.getType(), req.getParent()).promise();
                    resp = {
                        getUrn: () => mockurn,
                        getId: () => undefined,
                        getObject: () => req.getObject(),
                        getPropertydependenciesMap: () => undefined,
                    };
                }
            }
            catch (e) {
                err = e;
                resp = {
                    getUrn: () => "",
                    getId: () => undefined,
                    getObject: () => req.getObject(),
                    getPropertydependenciesMap: () => undefined,
                };
            }
            resop.resolveURN(resp.getUrn(), err);
            // Note: 'id || undefined' is intentional.  We intentionally collapse falsy values to
            // undefined so that later parts of our system don't have to deal with values like 'null'.
            if (resop.resolveID) {
                const id = resp.getId() || undefined;
                resop.resolveID(id, id !== undefined, err);
            }
            const deps = {};
            const rpcDeps = resp.getPropertydependenciesMap();
            if (rpcDeps) {
                for (const [k, propertyDeps] of resp.getPropertydependenciesMap().entries()) {
                    const urns = propertyDeps.getUrnsList();
                    deps[k] = urns.map(urn => newDependency(urn));
                }
            }
            // Now resolve the output properties.
            yield resolveOutputs(res, t, name, props, resp.getObject(), deps, resop.resolvers, err);
        }));
    })), label);
}
exports.registerResource = registerResource;
/**
 * Prepares for an RPC that will manufacture a resource, and hence deals with input and output
 * properties.
 */
function prepareResource(label, res, custom, props, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        // Simply initialize the URN property and get prepared to resolve it later on.
        // Note: a resource urn will always get a value, and thus the output property
        // for it can always run .apply calls.
        let resolveURN;
        {
            let resolveValue;
            let resolveIsKnown;
            res.urn = new output_1.Output(res, debuggable_1.debuggablePromise(new Promise(resolve => resolveValue = resolve), `resolveURN(${label})`), debuggable_1.debuggablePromise(new Promise(resolve => resolveIsKnown = resolve), `resolveURNIsKnown(${label})`), 
            /*isSecret:*/ Promise.resolve(false), Promise.resolve(res));
            resolveURN = (v, err) => {
                resolveValue(v);
                resolveIsKnown(err === undefined);
            };
        }
        // If a custom resource, make room for the ID property.
        let resolveID;
        if (custom) {
            let resolveValue;
            let resolveIsKnown;
            res.id = new output_1.Output(res, debuggable_1.debuggablePromise(new Promise(resolve => resolveValue = resolve), `resolveID(${label})`), debuggable_1.debuggablePromise(new Promise(resolve => resolveIsKnown = resolve), `resolveIDIsKnown(${label})`), Promise.resolve(false), Promise.resolve(res));
            resolveID = (v, isKnown, err) => {
                resolveValue(v);
                resolveIsKnown(err ? false : isKnown);
            };
        }
        // Now "transfer" all input properties into unresolved Promises on res.  This way,
        // this resource will look like it has all its output properties to anyone it is
        // passed to.  However, those promises won't actually resolve until the registerResource
        // RPC returns
        const resolvers = rpc_1.transferProperties(res, label, props);
        /** IMPORTANT!  We should never await prior to this line, otherwise the Resource will be partly uninitialized. */
        // Before we can proceed, all our dependencies must be finished.
        const explicitDirectDependencies = new Set(yield gatherExplicitDependencies(opts.dependsOn));
        // Serialize out all our props to their final values.  In doing so, we'll also collect all
        // the Resources pointed to by any Dependency objects we encounter, adding them to 'propertyDependencies'.
        const [serializedProps, propertyToDirectDependencies] = yield rpc_1.serializeResourceProperties(label, props);
        // Wait for the parent to complete.
        // If no parent was provided, parent to the root resource.
        const parentURN = opts.parent
            ? yield opts.parent.urn.promise()
            : yield settings_1.getRootResource();
        let providerRef;
        let importID;
        if (custom) {
            const customOpts = opts;
            importID = customOpts.import;
            providerRef = yield resource_1.ProviderResource.register(opts.provider);
        }
        // Collect the URNs for explicit/implicit dependencies for the engine so that it can understand
        // the dependency graph and optimize operations accordingly.
        // The list of all dependencies (implicit or explicit).
        const allDirectDependencies = new Set(explicitDirectDependencies);
        const allDirectDependencyURNs = yield getAllTransitivelyReferencedCustomResourceURNs(explicitDirectDependencies);
        const propertyToDirectDependencyURNs = new Map();
        for (const [propertyName, directDependencies] of propertyToDirectDependencies) {
            addAll(allDirectDependencies, directDependencies);
            const urns = yield getAllTransitivelyReferencedCustomResourceURNs(directDependencies);
            addAll(allDirectDependencyURNs, urns);
            propertyToDirectDependencyURNs.set(propertyName, urns);
        }
        // Wait for all aliases. Note that we use `res.__aliases` instead of `opts.aliases` as the former has been processed
        // in the Resource constructor prior to calling `registerResource` - both adding new inherited aliases and
        // simplifying aliases down to URNs.
        const aliases = [];
        const uniqueAliases = new Set();
        for (const alias of (res.__aliases || [])) {
            const aliasVal = yield output_1.output(alias).promise();
            if (!uniqueAliases.has(aliasVal)) {
                uniqueAliases.add(aliasVal);
                aliases.push(aliasVal);
            }
        }
        return {
            resolveURN: resolveURN,
            resolveID: resolveID,
            resolvers: resolvers,
            serializedProps: serializedProps,
            parentURN: parentURN,
            providerRef: providerRef,
            allDirectDependencyURNs: allDirectDependencyURNs,
            propertyToDirectDependencyURNs: propertyToDirectDependencyURNs,
            aliases: aliases,
            import: importID,
        };
    });
}
function addAll(to, from) {
    for (const val of from) {
        to.add(val);
    }
}
function getAllTransitivelyReferencedCustomResourceURNs(resources) {
    return __awaiter(this, void 0, void 0, function* () {
        // Go through 'resources', but transitively walk through **Component** resources, collecting any
        // of their child resources.  This way, a Component acts as an aggregation really of all the
        // reachable custom resources it parents.  This walking will transitively walk through other
        // child ComponentResources, but will stop when it hits custom resources.  in other words, if we
        // had:
        //
        //              Comp1
        //              /   \
        //          Cust1   Comp2
        //                  /   \
        //              Cust2   Cust3
        //              /
        //          Cust4
        //
        // Then the transitively reachable custom resources of Comp1 will be [Cust1, Cust2, Cust3]. It
        // will *not* include `Cust4`.
        // To do this, first we just get the transitively reachable set of resources (not diving
        // into custom resources).  In the above picture, if we start with 'Comp1', this will be
        // [Comp1, Cust1, Comp2, Cust2, Cust3]
        const transitivelyReachableResources = yield getTransitivelyReferencedChildResourcesOfComponentResources(resources);
        const transitivelyReachableCustomResources = [...transitivelyReachableResources].filter(r => resource_1.CustomResource.isInstance(r));
        const promises = transitivelyReachableCustomResources.map(r => r.urn.promise());
        const urns = yield Promise.all(promises);
        return new Set(urns);
    });
}
/**
 * Recursively walk the resources passed in, returning them and all resources reachable from
 * [Resource.__childResources] through any **Component** resources we encounter.
 */
function getTransitivelyReferencedChildResourcesOfComponentResources(resources) {
    return __awaiter(this, void 0, void 0, function* () {
        // Recursively walk the dependent resources through their children, adding them to the result set.
        const result = new Set();
        yield addTransitivelyReferencedChildResourcesOfComponentResources(resources, result);
        return result;
    });
}
function addTransitivelyReferencedChildResourcesOfComponentResources(resources, result) {
    return __awaiter(this, void 0, void 0, function* () {
        if (resources) {
            for (const resource of resources) {
                if (!result.has(resource)) {
                    result.add(resource);
                    if (resource_1.ComponentResource.isInstance(resource)) {
                        // This await is safe even if __isConstructed is undefined. Ensure that the
                        // resource has completely finished construction.  That way all parent/child
                        // relationships will have been setup.
                        yield resource.__data;
                        addTransitivelyReferencedChildResourcesOfComponentResources(resource.__childResources, result);
                    }
                }
            }
        }
    });
}
/**
 * Gathers explicit dependent Resources from a list of Resources (possibly Promises and/or Outputs).
 */
function gatherExplicitDependencies(dependsOn) {
    return __awaiter(this, void 0, void 0, function* () {
        if (dependsOn) {
            if (Array.isArray(dependsOn)) {
                const dos = [];
                for (const d of dependsOn) {
                    dos.push(...(yield gatherExplicitDependencies(d)));
                }
                return dos;
            }
            else if (dependsOn instanceof Promise) {
                return gatherExplicitDependencies(yield dependsOn);
            }
            else if (output_1.Output.isInstance(dependsOn)) {
                // Recursively gather dependencies, await the promise, and append the output's dependencies.
                const dos = dependsOn.apply(v => gatherExplicitDependencies(v));
                const urns = yield dos.promise();
                const dosResources = yield output_1.getAllResources(dos);
                const implicits = yield gatherExplicitDependencies([...dosResources]);
                return ((urns !== null && urns !== void 0 ? urns : [])).concat(implicits);
            }
            else {
                if (!resource_1.Resource.isInstance(dependsOn)) {
                    throw new Error("'dependsOn' was passed a value that was not a Resource.");
                }
                return [dependsOn];
            }
        }
        return [];
    });
}
/**
 * Finishes a resource creation RPC operation by resolving its outputs to the resulting RPC payload.
 */
function resolveOutputs(res, t, name, props, outputs, deps, resolvers, err) {
    return __awaiter(this, void 0, void 0, function* () {
        // Produce a combined set of property states, starting with inputs and then applying
        // outputs.  If the same property exists in the inputs and outputs states, the output wins.
        const allProps = {};
        if (outputs) {
            Object.assign(allProps, rpc_1.deserializeProperties(outputs));
        }
        const label = `resource:${name}[${t}]#...`;
        if (!settings_1.isDryRun() || settings_1.isLegacyApplyEnabled()) {
            for (const key of Object.keys(props)) {
                if (!allProps.hasOwnProperty(key)) {
                    // input prop the engine didn't give us a final value for.  Just use the value passed into the resource
                    // after round-tripping it through serialization. We do the round-tripping primarily s.t. we ensure that
                    // Output values are handled properly w.r.t. unknowns.
                    const inputProp = yield rpc_1.serializeProperty(label, props[key], new Set());
                    if (inputProp === undefined) {
                        continue;
                    }
                    allProps[key] = rpc_1.deserializeProperty(inputProp);
                }
            }
        }
        rpc_1.resolveProperties(res, resolvers, t, name, allProps, deps, err);
    });
}
/**
 * registerResourceOutputs completes the resource registration, attaching an optional set of computed outputs.
 */
function registerResourceOutputs(res, outputs) {
    // Now run the operation. Note that we explicitly do not serialize output registration with
    // respect to other resource operations, as outputs may depend on properties of other resources
    // that will not resolve until later turns. This would create a circular promise chain that can
    // never resolve.
    const opLabel = `monitor.registerResourceOutputs(...)`;
    runAsyncResourceOp(opLabel, () => __awaiter(this, void 0, void 0, function* () {
        // The registration could very well still be taking place, so we will need to wait for its URN.
        // Additionally, the output properties might have come from other resources, so we must await those too.
        const urn = yield res.urn.promise();
        const resolved = yield rpc_1.serializeProperties(opLabel, { outputs });
        const outputsObj = gstruct.Struct.fromJavaScript(resolved.outputs);
        log.debug(`RegisterResourceOutputs RPC prepared: urn=${urn}` +
            (settings_1.excessiveDebugOutput ? `, outputs=${JSON.stringify(outputsObj)}` : ``));
        // Fetch the monitor and make an RPC request.
        const monitor = settings_1.getMonitor();
        if (monitor) {
            const req = new resproto.RegisterResourceOutputsRequest();
            req.setUrn(urn);
            req.setOutputs(outputsObj);
            const label = `monitor.registerResourceOutputs(${urn}, ...)`;
            yield debuggable_1.debuggablePromise(new Promise((resolve, reject) => monitor.registerResourceOutputs(req, (err, innerResponse) => {
                log.debug(`RegisterResourceOutputs RPC finished: urn=${urn}; ` +
                    `err: ${err}, resp: ${innerResponse}`);
                if (err) {
                    // If the monitor is unavailable, it is in the process of shutting down or has already
                    // shut down. Don't emit an error and don't do any more RPCs, just exit.
                    if (err.code === grpc.status.UNAVAILABLE || err.code === grpc.status.CANCELLED) {
                        settings_1.terminateRpcs();
                        err.message = "Resource monitor is terminating";
                    }
                    reject(err);
                }
                else {
                    log.debug(`RegisterResourceOutputs RPC finished: urn=${urn}; ` +
                        `err: ${err}, resp: ${innerResponse}`);
                    resolve();
                }
            })), label);
        }
    }), false);
}
exports.registerResourceOutputs = registerResourceOutputs;
function isAny(o) {
    return true;
}
/**
 * listResourceOutputs returns the resource outputs (if any) for a stack, or an error if the stack
 * cannot be found. Resources are retrieved from the latest stack snapshot, which may include
 * ongoing updates.
 *
 * @param stackName Name of stack to retrieve resource outputs for. Defaults to the current stack.
 * @param typeFilter A [type
 * guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards)
 * that specifies which resource types to list outputs of.
 *
 * @example
 * const buckets = pulumi.runtime.listResourceOutput(aws.s3.Bucket.isInstance);
 */
function listResourceOutputs(typeFilter, stackName) {
    if (typeFilter === undefined) {
        typeFilter = isAny;
    }
    return query
        .from(invoke_1.invoke("pulumi:pulumi:readStackResourceOutputs", {
        stackName: stackName || settings_1.getStack(),
    }).then(({ outputs }) => utils.values(outputs)))
        .map(({ type: typ, outputs }) => {
        return Object.assign(Object.assign({}, outputs), { __pulumiType: typ });
    })
        .filter(typeFilter);
}
exports.listResourceOutputs = listResourceOutputs;
/**
 * resourceChain is used to serialize all resource requests.  If we don't do this, all resource operations will be
 * entirely asynchronous, meaning the dataflow graph that results will determine ordering of operations.  This
 * causes problems with some resource providers, so for now we will serialize all of them.  The issue
 * pulumi/pulumi#335 tracks coming up with a long-term solution here.
 */
let resourceChain = Promise.resolve();
let resourceChainLabel = undefined;
// runAsyncResourceOp runs an asynchronous resource operation, possibly serializing it as necessary.
function runAsyncResourceOp(label, callback, serial) {
    // Serialize the invocation if necessary.
    if (serial === undefined) {
        serial = settings_1.serialize();
    }
    const resourceOp = rpc_1.suppressUnhandledGrpcRejections(debuggable_1.debuggablePromise(resourceChain.then(() => __awaiter(this, void 0, void 0, function* () {
        if (serial) {
            resourceChainLabel = label;
            log.debug(`Resource RPC serialization requested: ${label} is current`);
        }
        return callback();
    })), label + "-initial"));
    // Ensure the process won't exit until this RPC call finishes and resolve it when appropriate.
    const done = settings_1.rpcKeepAlive();
    const finalOp = debuggable_1.debuggablePromise(resourceOp.then(() => { done(); }, () => { done(); }), label + "-final");
    // Set up another promise that propagates the error, if any, so that it triggers unhandled rejection logic.
    resourceOp.catch((err) => Promise.reject(err));
    // If serialization is requested, wait for the prior resource operation to finish before we proceed, serializing
    // them, and make this the current resource operation so that everybody piles up on it.
    if (serial) {
        resourceChain = finalOp;
        if (resourceChainLabel) {
            log.debug(`Resource RPC serialization requested: ${label} is behind ${resourceChainLabel}`);
        }
    }
}
