"use strict";
// Copyright 2016-2020, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../../errors");
const log = require("../../log");
const runtime = require("../../runtime");
const langproto = require("../../proto/language_pb.js");
const plugproto = require("../../proto/plugin_pb.js");
// maxRPCMessageSize raises the gRPC Max Message size from `4194304` (4mb) to `419430400` (400mb)
/** @internal */
exports.maxRPCMessageSize = 1024 * 1024 * 400;
/** @internal */
class LanguageServer {
    constructor(program) {
        this.program = program;
        this.result = new Promise((resolve, reject) => {
            this.resolveResult = resolve;
            this.rejectResult = reject;
        });
        this.running = false;
    }
    getExitError(preview) {
        return new Error(this.pulumiExitCode === 0 ?
            "pulumi exited prematurely" :
            `${preview ? "preview" : "update"} failed with code ${this.pulumiExitCode}`);
    }
    onPulumiExit(code, preview) {
        this.pulumiExitCode = code;
        // these are globals and we need to clean up after ourselves
        runtime.resetOptions("", "", -1, "", "", false);
        if (!this.running) {
            this.rejectResult(this.getExitError(preview));
        }
    }
    getRequiredPlugins(call, callback) {
        const resp = new langproto.GetRequiredPluginsResponse();
        resp.setPluginsList([]);
        callback(undefined, resp);
    }
    run(call, callback) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const req = call.request;
            const resp = new langproto.RunResponse();
            if (this.pulumiExitCode !== undefined) {
                callback(this.getExitError(req.getDryrun()));
                return;
            }
            this.running = true;
            const errorSet = new Set();
            const uncaughtHandler = newUncaughtHandler(errorSet);
            let result;
            try {
                const args = req.getArgsList();
                const engineAddr = args && args.length > 0 ? args[0] : "";
                runtime.resetOptions(req.getProject(), req.getStack(), req.getParallel(), engineAddr, req.getMonitorAddress(), req.getDryrun());
                const config = {};
                for (const [k, v] of ((_a = req.getConfigMap()) === null || _a === void 0 ? void 0 : _a.entries()) || []) {
                    config[k] = v;
                }
                runtime.setAllConfig(config);
                process.on("uncaughtException", uncaughtHandler);
                // @ts-ignore 'unhandledRejection' will almost always invoke uncaughtHandler with an Error. so
                // just suppress the TS strictness here.
                process.on("unhandledRejection", uncaughtHandler);
                try {
                    yield runtime.runInPulumiStack(() => __awaiter(this, void 0, void 0, function* () {
                        result = this.program();
                        return result;
                    }));
                    yield runtime.disconnect();
                    process.off("uncaughtException", uncaughtHandler);
                    process.off("unhandledRejection", uncaughtHandler);
                }
                catch (e) {
                    yield runtime.disconnect();
                    process.off("uncaughtException", uncaughtHandler);
                    process.off("unhandledRejection", uncaughtHandler);
                    if (!errors_1.isGrpcError(e)) {
                        throw e;
                    }
                }
                if (errorSet.size !== 0 || log.hasErrors()) {
                    throw new Error("One or more errors occurred");
                }
                const [leaks, leakMessage] = runtime.leakedPromises();
                if (leaks.size !== 0) {
                    throw new Error(leakMessage);
                }
                this.resolveResult(result);
            }
            catch (e) {
                const err = e instanceof Error ? e : new Error(`unknown error ${e}`);
                resp.setError(err.message);
                this.rejectResult(err);
            }
            callback(undefined, resp);
        });
    }
    getPluginInfo(call, callback) {
        const resp = new plugproto.PluginInfo();
        resp.setVersion("1.0.0");
        callback(undefined, resp);
    }
}
exports.LanguageServer = LanguageServer;
function newUncaughtHandler(errorSet) {
    return (err) => {
        // In node, if you throw an error in a chained promise, but the exception is not finally
        // handled, then you can end up getting an unhandledRejection for each exception/promise
        // pair.  Because the exception is the same through all of these, we keep track of it and
        // only report it once so the user doesn't get N messages for the same thing.
        if (errorSet.has(err)) {
            return;
        }
        errorSet.add(err);
        // Default message should be to include the full stack (which includes the message), or
        // fallback to just the message if we can't get the stack.
        //
        // If both the stack and message are empty, then just stringify the err object itself. This
        // is also necessary as users can throw arbitrary things in JS (including non-Errors).
        const defaultMessage = err.stack || err.message || ("" + err);
        // First, log the error.
        if (errors_1.RunError.isInstance(err)) {
            // Always hide the stack for RunErrors.
            log.error(err.message);
        }
        else if (errors_1.ResourceError.isInstance(err)) {
            // Hide the stack if requested to by the ResourceError creator.
            const message = err.hideStack ? err.message : defaultMessage;
            log.error(message, err.resource);
        }
        else if (!errors_1.isGrpcError(err)) {
            log.error(`Unhandled exception: ${defaultMessage}`);
        }
    };
}
