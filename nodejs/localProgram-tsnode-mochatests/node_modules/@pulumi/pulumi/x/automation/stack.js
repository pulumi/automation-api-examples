"use strict";
// Copyright 2016-2020, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const grpc = require("@grpc/grpc-js");
const cmd_1 = require("./cmd");
const errors_1 = require("./errors");
const server_1 = require("./server");
const langrpc = require("../../proto/language_grpc_pb.js");
/**
 * Stack is an isolated, independently configurable instance of a Pulumi program.
 * Stack exposes methods for the full pulumi lifecycle (up/preview/refresh/destroy), as well as managing configuration.
 * Multiple Stacks are commonly used to denote different phases of development
 * (such as development, staging and production) or feature branches (such as feature-x-dev, jane-feature-x-dev).
 *
 * @alpha
 */
class Stack {
    constructor(name, workspace, mode) {
        this.name = name;
        this.workspace = workspace;
        switch (mode) {
            case "create":
                this.ready = workspace.createStack(name);
                return this;
            case "select":
                this.ready = workspace.selectStack(name);
                return this;
            case "createOrSelect":
                this.ready = workspace.createStack(name).catch((err) => {
                    if (err instanceof errors_1.StackAlreadyExistsError) {
                        return workspace.selectStack(name);
                    }
                    throw err;
                });
                return this;
            default:
                throw new Error(`unexpected Stack creation mode: ${mode}`);
        }
    }
    /**
     * Creates a new stack using the given workspace, and stack name.
     * It fails if a stack with that name already exists
     *
     * @param name The name identifying the Stack.
     * @param workspace The Workspace the Stack was created from.
     */
    static create(name, workspace) {
        return __awaiter(this, void 0, void 0, function* () {
            const stack = new Stack(name, workspace, "create");
            yield stack.ready;
            return stack;
        });
    }
    /**
     * Selects stack using the given workspace, and stack name.
     * It returns an error if the given Stack does not exist. All LocalWorkspace operations will call `select`
     * before running.
     *
     * @param name The name identifying the Stack.
     * @param workspace The Workspace the Stack was created from.
     */
    static select(name, workspace) {
        return __awaiter(this, void 0, void 0, function* () {
            const stack = new Stack(name, workspace, "select");
            yield stack.ready;
            return stack;
        });
    }
    /**
     * Tries to create a new stack using the given workspace and
     * stack name if the stack does not already exist,
     * or falls back to selecting the existing stack. If the stack does not exist,
     * it will be created and selected.
     *
     * @param name The name identifying the Stack.
     * @param workspace The Workspace the Stack was created from.
     */
    static createOrSelect(name, workspace) {
        return __awaiter(this, void 0, void 0, function* () {
            const stack = new Stack(name, workspace, "createOrSelect");
            yield stack.ready;
            return stack;
        });
    }
    /**
     * Creates or updates the resources in a stack by executing the program in the Workspace.
     * https://www.pulumi.com/docs/reference/cli/pulumi_up/
     *
     * @param opts Options to customize the behavior of the update.
     */
    up(opts) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["up", "--yes", "--skip-preview"];
            let kind = execKind.local;
            let program = this.workspace.program;
            yield this.workspace.selectStack(this.name);
            if (opts) {
                if (opts.program) {
                    program = opts.program;
                }
                if (opts.message) {
                    args.push("--message", opts.message);
                }
                if (opts.expectNoChanges) {
                    args.push("--expect-no-changes");
                }
                if (opts.replace) {
                    for (const rURN of opts.replace) {
                        args.push("--replace", rURN);
                    }
                }
                if (opts.target) {
                    for (const tURN of opts.target) {
                        args.push("--target", tURN);
                    }
                }
                if (opts.targetDependents) {
                    args.push("--target-dependents");
                }
                if (opts.parallel) {
                    args.push("--parallel", opts.parallel.toString());
                }
            }
            let onExit = (code) => { return; };
            if (program) {
                kind = execKind.inline;
                const server = new grpc.Server({
                    "grpc.max_receive_message_length": server_1.maxRPCMessageSize,
                });
                const languageServer = new server_1.LanguageServer(program);
                server.addService(langrpc.LanguageRuntimeService, languageServer);
                const port = yield new Promise((resolve, reject) => {
                    server.bindAsync(`0.0.0.0:0`, grpc.ServerCredentials.createInsecure(), (err, p) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(p);
                        }
                    });
                });
                server.start();
                onExit = (code) => {
                    languageServer.onPulumiExit(code, false /* preview */);
                    server.forceShutdown();
                };
                args.push(`--client=127.0.0.1:${port}`);
            }
            args.push("--exec-kind", kind);
            const upResult = yield this.runPulumiCmd(args, (_a = opts) === null || _a === void 0 ? void 0 : _a.onOutput);
            onExit(upResult.code);
            // TODO: do this in parallel after this is fixed https://github.com/pulumi/pulumi/issues/3877
            const outputs = yield this.outputs();
            const summary = yield this.info();
            const result = {
                stdout: upResult.stdout,
                stderr: upResult.stderr,
                summary: summary,
                outputs,
            };
            return result;
        });
    }
    /**
     * Preforms a dry-run update to a stack, returning pending changes.
     * https://www.pulumi.com/docs/reference/cli/pulumi_preview/
     *
     * @param opts Options to customize the behavior of the preview.
     */
    preview(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO JSON
            const args = ["preview"];
            let kind = execKind.local;
            let program = this.workspace.program;
            yield this.workspace.selectStack(this.name);
            if (opts) {
                if (opts.program) {
                    program = opts.program;
                }
                if (opts.message) {
                    args.push("--message", opts.message);
                }
                if (opts.expectNoChanges) {
                    args.push("--expect-no-changes");
                }
                if (opts.replace) {
                    for (const rURN of opts.replace) {
                        args.push("--replace", rURN);
                    }
                }
                if (opts.target) {
                    for (const tURN of opts.target) {
                        args.push("--target", tURN);
                    }
                }
                if (opts.targetDependents) {
                    args.push("--target-dependents");
                }
                if (opts.parallel) {
                    args.push("--parallel", opts.parallel.toString());
                }
            }
            let onExit = (code) => { return; };
            if (program) {
                kind = execKind.inline;
                const server = new grpc.Server({
                    "grpc.max_receive_message_length": server_1.maxRPCMessageSize,
                });
                const languageServer = new server_1.LanguageServer(program);
                server.addService(langrpc.LanguageRuntimeService, languageServer);
                const port = yield new Promise((resolve, reject) => {
                    server.bindAsync(`0.0.0.0:0`, grpc.ServerCredentials.createInsecure(), (err, p) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(p);
                        }
                    });
                });
                server.start();
                onExit = (code) => {
                    languageServer.onPulumiExit(code, false /* preview */);
                    server.forceShutdown();
                };
                args.push(`--client=127.0.0.1:${port}`);
            }
            args.push("--exec-kind", kind);
            const preResult = yield this.runPulumiCmd(args);
            onExit(preResult.code);
            const summary = yield this.info();
            const result = {
                stdout: preResult.stdout,
                stderr: preResult.stderr,
                summary: summary,
            };
            return result;
        });
    }
    /**
     * Compares the current stackâ€™s resource state with the state known to exist in the actual
     * cloud provider. Any such changes are adopted into the current stack.
     *
     * @param opts Options to customize the behavior of the refresh.
     */
    refresh(opts) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["refresh", "--yes", "--skip-preview"];
            yield this.workspace.selectStack(this.name);
            if (opts) {
                if (opts.message) {
                    args.push("--message", opts.message);
                }
                if (opts.expectNoChanges) {
                    args.push("--expect-no-changes");
                }
                if (opts.target) {
                    for (const tURN of opts.target) {
                        args.push("--target", tURN);
                    }
                }
                if (opts.parallel) {
                    args.push("--parallel", opts.parallel.toString());
                }
            }
            const refResult = yield this.runPulumiCmd(args, (_a = opts) === null || _a === void 0 ? void 0 : _a.onOutput);
            const summary = yield this.info();
            const result = {
                stdout: refResult.stdout,
                stderr: refResult.stderr,
                summary: summary,
            };
            return result;
        });
    }
    /**
     * Destroy deletes all resources in a stack, leaving all history and configuration intact.
     *
     * @param opts Options to customize the behavior of the destroy.
     */
    destroy(opts) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["destroy", "--yes", "--skip-preview"];
            yield this.workspace.selectStack(this.name);
            if (opts) {
                if (opts.message) {
                    args.push("--message", opts.message);
                }
                if (opts.target) {
                    for (const tURN of opts.target) {
                        args.push("--target", tURN);
                    }
                }
                if (opts.targetDependents) {
                    args.push("--target-dependents");
                }
                if (opts.parallel) {
                    args.push("--parallel", opts.parallel.toString());
                }
            }
            const preResult = yield this.runPulumiCmd(args, (_a = opts) === null || _a === void 0 ? void 0 : _a.onOutput);
            const summary = yield this.info();
            const result = {
                stdout: preResult.stdout,
                stderr: preResult.stderr,
                summary: summary,
            };
            return result;
        });
    }
    /**
     * Returns the config value associated with the specified key.
     *
     * @param key The key to use for the config lookup
     */
    getConfig(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.getConfig(this.name, key);
        });
    }
    /**
     * Returns the full config map associated with the stack in the Workspace.
     */
    getAllConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.getAllConfig(this.name);
        });
    }
    /**
     * Sets a config key-value pair on the Stack in the associated Workspace.
     *
     * @param key The key to set.
     * @param value The config value to set.
     */
    setConfig(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.setConfig(this.name, key, value);
        });
    }
    /**
     * Sets all specified config values on the stack in the associated Workspace.
     *
     * @param config The map of config key-value pairs to set.
     */
    setAllConfig(config) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.setAllConfig(this.name, config);
        });
    }
    /**
     * Removes the specified config key from the Stack in the associated Workspace.
     *
     * @param key The config key to remove.
     */
    removeConfig(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.removeConfig(this.name, key);
        });
    }
    /**
     * Removes the specified config keys from the Stack in the associated Workspace.
     *
     * @param keys The config keys to remove.
     */
    removeAllConfig(keys) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.removeAllConfig(this.name, keys);
        });
    }
    /**
     * Gets and sets the config map used with the last update.
     */
    refreshConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.refreshConfig(this.name);
        });
    }
    /**
     * Gets the current set of Stack outputs from the last Stack.up().
     */
    outputs() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.workspace.selectStack(this.name);
            // TODO: do this in parallel after this is fixed https://github.com/pulumi/pulumi/issues/3877
            const maskedResult = yield this.runPulumiCmd(["stack", "output", "--json"]);
            const plaintextResult = yield this.runPulumiCmd(["stack", "output", "--json", "--show-secrets"]);
            const maskedOuts = JSON.parse(maskedResult.stdout);
            const plaintextOuts = JSON.parse(plaintextResult.stdout);
            const outputs = {};
            const secretSentinal = "[secret]";
            for (const [key, value] of Object.entries(plaintextOuts)) {
                const secret = maskedOuts[key] === secretSentinal;
                outputs[key] = { value, secret };
            }
            return outputs;
        });
    }
    /**
     * Returns a list summarizing all previous and current results from Stack lifecycle operations
     * (up/preview/refresh/destroy).
     */
    history() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.runPulumiCmd(["history", "--json", "--show-secrets"]);
            const summaries = JSON.parse(result.stdout, (key, value) => {
                if (key === "startTime" || key === "endTime") {
                    return new Date(value);
                }
                return value;
            });
            return summaries;
        });
    }
    info() {
        return __awaiter(this, void 0, void 0, function* () {
            const history = yield this.history();
            if (!history || history.length === 0) {
                return undefined;
            }
            return history[0];
        });
    }
    runPulumiCmd(args, onOutput) {
        return __awaiter(this, void 0, void 0, function* () {
            let envs = {};
            const pulumiHome = this.workspace.pulumiHome;
            if (pulumiHome) {
                envs["PULUMI_HOME"] = pulumiHome;
            }
            envs = Object.assign(Object.assign({}, envs), this.workspace.envVars);
            const additionalArgs = yield this.workspace.serializeArgsForOp(this.name);
            args = [...args, ...additionalArgs];
            const result = yield cmd_1.runPulumiCmd(args, this.workspace.workDir, envs, onOutput);
            yield this.workspace.postCommandCallback(this.name);
            return result;
        });
    }
}
exports.Stack = Stack;
/**
 * Returns a stack name formatted with the greatest possible specificity:
 * org/project/stack or user/project/stack
 * Using this format avoids ambiguity in stack identity guards creating or selecting the wrong stack.
 * Note that filestate backends (local file, S3, Azure Blob) do not support stack names in this
 * format, and instead only use the stack name without an org/user or project to qualify it.
 * See: https://github.com/pulumi/pulumi/issues/2522
 *
 * @param org The org (or user) that contains the Stack.
 * @param project The project that parents the Stack.
 * @param stack The name of the Stack.
 */
function fullyQualifiedStackName(org, project, stack) {
    return `${org}/${project}/${stack}`;
}
exports.fullyQualifiedStackName = fullyQualifiedStackName;
const execKind = {
    local: "auto.local",
    inline: "auto.inline",
};
