"use strict";
// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
Object.defineProperty(exports, "__esModule", { value: true });
const pulumi = require("@pulumi/pulumi");
const utilities = require("../utilities");
/**
 * Manages a Kinesis Analytics v2 Application.
 * This resource can be used to manage both Kinesis Data Analytics for SQL applications and Kinesis Data Analytics for Apache Flink applications.
 *
 * > **Note:** Kinesis Data Analytics for SQL applications created using this resource cannot currently be viewed in the AWS Console. To manage Kinesis Data Analytics for SQL applications that can also be viewed in the AWS Console, use the [`aws.kinesis.AnalyticsApplication`](https://www.terraform.io/docs/providers/aws/r/kinesis_analytics_application.html) resource.
 *
 * ## Example Usage
 * ### Apache Flink Application
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const exampleBucket = new aws.s3.Bucket("exampleBucket", {});
 * const exampleBucketObject = new aws.s3.BucketObject("exampleBucketObject", {
 *     bucket: exampleBucket.bucket,
 *     key: "example-flink-application",
 *     source: new pulumi.asset.FileAsset("flink-app.jar"),
 * });
 * const exampleApplication = new aws.kinesisanalyticsv2.Application("exampleApplication", {
 *     runtimeEnvironment: "FLINK-1_8",
 *     serviceExecutionRole: aws_iam_role.example.arn,
 *     applicationConfiguration: {
 *         applicationCodeConfiguration: {
 *             codeContent: {
 *                 s3ContentLocation: {
 *                     bucketArn: exampleBucket.arn,
 *                     fileKey: exampleBucketObject.key,
 *                 },
 *             },
 *             codeContentType: "ZIPFILE",
 *         },
 *         environmentProperties: {
 *             propertyGroups: [
 *                 {
 *                     propertyGroupId: "PROPERTY-GROUP-1",
 *                     propertyMap: {
 *                         Key1: "Value1",
 *                     },
 *                 },
 *                 {
 *                     propertyGroupId: "PROPERTY-GROUP-2",
 *                     propertyMap: {
 *                         KeyA: "ValueA",
 *                         KeyB: "ValueB",
 *                     },
 *                 },
 *             ],
 *         },
 *         flinkApplicationConfiguration: {
 *             checkpointConfiguration: {
 *                 configurationType: "DEFAULT",
 *             },
 *             monitoringConfiguration: {
 *                 configurationType: "CUSTOM",
 *                 logLevel: "DEBUG",
 *                 metricsLevel: "TASK",
 *             },
 *             parallelismConfiguration: {
 *                 autoScalingEnabled: true,
 *                 configurationType: "CUSTOM",
 *                 parallelism: 10,
 *                 parallelismPerKpu: 4,
 *             },
 *         },
 *     },
 *     tags: {
 *         Environment: "test",
 *     },
 * });
 * ```
 * ### SQL Application
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const exampleLogGroup = new aws.cloudwatch.LogGroup("exampleLogGroup", {});
 * const exampleLogStream = new aws.cloudwatch.LogStream("exampleLogStream", {logGroupName: exampleLogGroup.name});
 * const exampleApplication = new aws.kinesisanalyticsv2.Application("exampleApplication", {
 *     runtimeEnvironment: "SQL-1.0",
 *     serviceExecutionRole: aws_iam_role.example.arn,
 *     applicationConfiguration: {
 *         applicationCodeConfiguration: {
 *             codeContent: {
 *                 textContent: "SELECT 1;\n",
 *             },
 *             codeContentType: "PLAINTEXT",
 *         },
 *         sqlApplicationConfiguration: {
 *             input: {
 *                 namePrefix: "PREFIX_1",
 *                 inputParallelism: {
 *                     count: 3,
 *                 },
 *                 inputSchema: {
 *                     recordColumns: [
 *                         {
 *                             name: "COLUMN_1",
 *                             sqlType: "VARCHAR(8)",
 *                             mapping: "MAPPING-1",
 *                         },
 *                         {
 *                             name: "COLUMN_2",
 *                             sqlType: "DOUBLE",
 *                         },
 *                     ],
 *                     recordEncoding: "UTF-8",
 *                     recordFormat: {
 *                         recordFormatType: "CSV",
 *                         mappingParameters: {
 *                             csvMappingParameters: {
 *                                 recordColumnDelimiter: ",",
 *                                 recordRowDelimiter: "\n",
 *                             },
 *                         },
 *                     },
 *                 },
 *                 kinesisStreamsInput: {
 *                     resourceArn: aws_kinesis_stream.example.arn,
 *                 },
 *             },
 *             outputs: [
 *                 {
 *                     name: "OUTPUT_1",
 *                     destinationSchema: {
 *                         recordFormatType: "JSON",
 *                     },
 *                     lambdaOutput: {
 *                         resourceArn: aws_lambda_function.example.arn,
 *                     },
 *                 },
 *                 {
 *                     name: "OUTPUT_2",
 *                     destinationSchema: {
 *                         recordFormatType: "CSV",
 *                     },
 *                     kinesisFirehoseOutput: {
 *                         resourceArn: aws_kinesis_firehose_delivery_stream.example.arn,
 *                     },
 *                 },
 *             ],
 *             referenceDataSource: {
 *                 tableName: "TABLE-1",
 *                 referenceSchema: {
 *                     recordColumns: [{
 *                         name: "COLUMN_1",
 *                         sqlType: "INTEGER",
 *                     }],
 *                     recordFormat: {
 *                         recordFormatType: "JSON",
 *                         mappingParameters: {
 *                             jsonMappingParameters: {
 *                                 recordRowPath: "$",
 *                             },
 *                         },
 *                     },
 *                 },
 *                 s3ReferenceDataSource: {
 *                     bucketArn: aws_s3_bucket.example.arn,
 *                     fileKey: "KEY-1",
 *                 },
 *             },
 *         },
 *     },
 *     cloudwatchLoggingOptions: {
 *         logStreamArn: exampleLogStream.arn,
 *     },
 * });
 * ```
 * ### VPC Configuration
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const exampleBucket = new aws.s3.Bucket("exampleBucket", {});
 * const exampleBucketObject = new aws.s3.BucketObject("exampleBucketObject", {
 *     bucket: exampleBucket.bucket,
 *     key: "example-flink-application",
 *     source: new pulumi.asset.FileAsset("flink-app.jar"),
 * });
 * const exampleApplication = new aws.kinesisanalyticsv2.Application("exampleApplication", {
 *     runtimeEnvironment: "FLINK-1_8",
 *     serviceExecutionRole: aws_iam_role.example.arn,
 *     applicationConfiguration: {
 *         applicationCodeConfiguration: {
 *             codeContent: {
 *                 s3ContentLocation: {
 *                     bucketArn: exampleBucket.arn,
 *                     fileKey: exampleBucketObject.key,
 *                 },
 *             },
 *             codeContentType: "ZIPFILE",
 *         },
 *         vpcConfiguration: {
 *             securityGroupIds: [
 *                 aws_security_group.example[0].id,
 *                 aws_security_group.example[1].id,
 *             ],
 *             subnetIds: [aws_subnet.example.id],
 *         },
 *     },
 * });
 * ```
 *
 * ## Import
 *
 * `aws_kinesisanalyticsv2_application` can be imported by using the application ARN, e.g.
 *
 * ```sh
 *  $ pulumi import aws:kinesisanalyticsv2/application:Application example arn:aws:kinesisanalytics:us-west-2:123456789012:application/example-sql-application
 * ```
 */
class Application extends pulumi.CustomResource {
    constructor(name, argsOrState, opts) {
        let inputs = {};
        if (opts && opts.id) {
            const state = argsOrState;
            inputs["applicationConfiguration"] = state ? state.applicationConfiguration : undefined;
            inputs["arn"] = state ? state.arn : undefined;
            inputs["cloudwatchLoggingOptions"] = state ? state.cloudwatchLoggingOptions : undefined;
            inputs["createTimestamp"] = state ? state.createTimestamp : undefined;
            inputs["description"] = state ? state.description : undefined;
            inputs["lastUpdateTimestamp"] = state ? state.lastUpdateTimestamp : undefined;
            inputs["name"] = state ? state.name : undefined;
            inputs["runtimeEnvironment"] = state ? state.runtimeEnvironment : undefined;
            inputs["serviceExecutionRole"] = state ? state.serviceExecutionRole : undefined;
            inputs["status"] = state ? state.status : undefined;
            inputs["tags"] = state ? state.tags : undefined;
            inputs["versionId"] = state ? state.versionId : undefined;
        }
        else {
            const args = argsOrState;
            if ((!args || args.runtimeEnvironment === undefined) && !(opts && opts.urn)) {
                throw new Error("Missing required property 'runtimeEnvironment'");
            }
            if ((!args || args.serviceExecutionRole === undefined) && !(opts && opts.urn)) {
                throw new Error("Missing required property 'serviceExecutionRole'");
            }
            inputs["applicationConfiguration"] = args ? args.applicationConfiguration : undefined;
            inputs["cloudwatchLoggingOptions"] = args ? args.cloudwatchLoggingOptions : undefined;
            inputs["description"] = args ? args.description : undefined;
            inputs["name"] = args ? args.name : undefined;
            inputs["runtimeEnvironment"] = args ? args.runtimeEnvironment : undefined;
            inputs["serviceExecutionRole"] = args ? args.serviceExecutionRole : undefined;
            inputs["tags"] = args ? args.tags : undefined;
            inputs["arn"] = undefined /*out*/;
            inputs["createTimestamp"] = undefined /*out*/;
            inputs["lastUpdateTimestamp"] = undefined /*out*/;
            inputs["status"] = undefined /*out*/;
            inputs["versionId"] = undefined /*out*/;
        }
        if (!opts) {
            opts = {};
        }
        if (!opts.version) {
            opts.version = utilities.getVersion();
        }
        super(Application.__pulumiType, name, inputs, opts);
    }
    /**
     * Get an existing Application resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    static get(name, id, state, opts) {
        return new Application(name, state, Object.assign(Object.assign({}, opts), { id: id }));
    }
    /**
     * Returns true if the given object is an instance of Application.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Application.__pulumiType;
    }
}
exports.Application = Application;
/** @internal */
Application.__pulumiType = 'aws:kinesisanalyticsv2/application:Application';
//# sourceMappingURL=application.js.map